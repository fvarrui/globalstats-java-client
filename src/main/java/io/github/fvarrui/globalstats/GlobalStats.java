package io.github.fvarrui.globalstats;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import io.github.fvarrui.globalstats.adapters.LocalDateTimeAdapter;
import io.github.fvarrui.globalstats.internal.GlobalStatsInterface;
import io.github.fvarrui.globalstats.internal.model.AccessToken;
import io.github.fvarrui.globalstats.internal.model.SectionResults;
import io.github.fvarrui.globalstats.internal.model.StatsQuery;
import io.github.fvarrui.globalstats.model.Achievement;
import io.github.fvarrui.globalstats.model.Error;
import io.github.fvarrui.globalstats.model.Rank;
import io.github.fvarrui.globalstats.model.Stats;
import io.github.fvarrui.globalstats.model.Section;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;

/**
 * GlobalStats API client
 * @see <a hred="https://globalstats.io/api">GlobalStats API docs</a>
 * @author fvarrui
 */
public class GlobalStats {
	
	private static final String BASE_URL = "https://api.globalstats.io/"; 

	private String clientId;
	private String clientSecret;
	private AccessToken token;
	private LocalDateTime tokenExpirationDate;
	private GlobalStatsInterface service;
	private Gson gson;
	
	/**
	 * Initialize the GlobalStatst API client  
	 * @param clientId Client ID generated by globalstats.io
	 * @param clientSecret Client secret generated by globalstats.io
	 */
	public GlobalStats(String clientId, String clientSecret) {
		
		this.clientId = clientId;
		this.clientSecret = clientSecret;
		
		// builds and customizes Gson serializer/deserializer
		gson = new GsonBuilder()
				.setPrettyPrinting()
				.registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.create();
		
		// builds retrofit
		Retrofit retrofit = new Retrofit.Builder()
				.baseUrl(BASE_URL)
				.addConverterFactory(GsonConverterFactory.create(gson))
				.build();
		
		// uses retrofit to create the api client implementation
		service = retrofit.create(GlobalStatsInterface.class);
		
	}
	
	/**
	 * Check if API request was successful
	 * @param response API response 
	 * @throws Exception Throwed if wrong response received
	 */
	private void assertResponse(Response<?> response) throws Exception {
		if (!response.isSuccessful()) {
			Error error = gson.fromJson(response.errorBody().string(), Error.class);
			throw new GlobalStatsException(error);
		}
	}
	
	/**
	 * Request a new access token
	 * @param clientId Client ID
	 * @param clientSecret Client secret
	 * @return Full access token data
	 * @throws Exception If something went wrong
	 */
	private AccessToken renewAccessToken(String clientId, String clientSecret) throws Exception {		
		Response<AccessToken> response = service.getAccessToken(
			"client_credentials", 
			"endpoint_client", 
			clientId, 
			clientSecret
		).execute();
		assertResponse(response);
		return response.body();
	}
	
	/**
	 * Returns the current access token, or request a new one if null or expired.
	 * @return Access token
	 * @throws Exception
	 */
	public String getAccessToken() throws Exception {
		if (token == null || LocalDateTime.now().isAfter(tokenExpirationDate)) {
			token = renewAccessToken(clientId, clientSecret);
			tokenExpirationDate = LocalDateTime.now().plusSeconds(token.getExpiresIn());			
		}
		return token.getAccessToken();
	}
	
	/**
	 * Creates statistics for a new user.
	 * @param name User name
	 * @param values GTD values to be stored 
	 * @return Stored statistics and the new user ID (save this value to access and update user specific stats)
	 * @throws Exception If something went wrong
	 */
	public Stats createStats(String name, Map<String, Object> values) throws Exception {
		Response<Stats> response = service.createStats(
			"Bearer " + getAccessToken(), 
			new StatsQuery(name, values)
		).execute();
		assertResponse(response);
		return response.body();
	}
	
	/**
	 * Update statistics for an existing user.
	 * @param id User ID
	 * @param values GTD values to be updated/stored
	 * @return Resulting stats
	 * @throws Exception If something went wrong
	 */
	public Stats updateStats(String id, Map<String, Object> values) throws Exception {
		Response<Stats> response = service.updateStats(
			"Bearer " + getAccessToken(),
			id,
			new StatsQuery(values)
		).execute();
		assertResponse(response);
		response.body().setId(id);		
		return response.body();
	}
	
	/**
	 * Get use statistics
	 * @param id User ID
	 * @return Current user statistics
	 * @throws Exception If something went wrong
	 */
	public Stats getStats(String id) throws Exception {
		Response<Stats> response = service.getStats(
			"Bearer " + getAccessToken(),
			id
		).execute();
		assertResponse(response);
		response.body().setId(id);
		return response.body();
	}
	
	/**
	 * Gets user stats section (stats compared to better and worse users) 
	 * @param id User Id
	 * @param key GTD key to be compared
	 * @return User ranking position
	 * @throws Exception If something went wrong
	 */
	public Section getStatsSection(String id, String key) throws Exception {
		Response<SectionResults> response = service.getSection(
			"Bearer " + getAccessToken(),
			id,
			key
		).execute();
		assertResponse(response);
		SectionResults results = response.body();
		return new Section(results.getUserRank(), results.getBetterRanks().get("data"), results.getWorseRanks().get("data"));
	}
	
	/**
	 * Get leaderboard (high scores)
	 * @param key GTD key used for sorting the leaderboard
	 * @param limit Number of users (from 1..limit). 0 returns just the first one.
	 * @param additionals Additonal GTDs
	 * @return Top ranking
	 * @throws Exception If somethign went wrong
	 */
	@SuppressWarnings("serial")
	public List<Rank> getLeaderboard(String key, int limit, String ... additionals) throws Exception {
		Map<String, Object> query = new HashMap<String, Object>() {{
			put("limit", limit);
			put("additionals", additionals);
		}};		
		Response<Map<String, List<Rank>>> response = service.getLeaderboard(
			"Bearer " + getAccessToken(),
			key,
			query
		).execute();
		assertResponse(response);
		return response.body().get("data");
	}
	
	/**
	 * Gets all registered achievements
	 * @return All achievements
	 * @throws Exception If something went wrong
	 */
	public List<Achievement> getAllAchievements() throws Exception {
		Response<Map<String, List<Achievement>>> response = service.getAllAchievements(
			"Bearer " + getAccessToken()
		).execute();
		assertResponse(response);
		response.body();
		return response.body().get("achievements");
	}

	/**
	 * Manually sets an achievement as accomplished for a specific user. 
	 * @param id User ID
	 * @param achievement Achievement key
	 * @return New user achievement
	 * @throws Exception If something went wrong
	 */
	public Achievement accomplish(String id, String achievement) throws Exception {
		Response<Map<String, Achievement>> response = service.accomplish(
			"Bearer " + getAccessToken(),
			id,
			achievement
		).execute();
		assertResponse(response);
		response.body();
		return response.body().get("achievement");
	}

	/**
	 * Get user achievements
	 * @param id User ID
	 * @return Achievements
	 * @throws Exception If something went wrong
	 */
	public List<Achievement> getUserAchievements(String id) throws Exception {
		Response<Map<String, List<Achievement>>> response = service.getAllAchievements(
			"Bearer " + getAccessToken()
		).execute();
		assertResponse(response);
		response.body();
		return response.body().get("achievements");
	}
	
}
